## 1. 复杂性

**案例：电商购物车系统**

一个看似简单的购物车功能，实际上涉及：

- 用户登录状态管理
- 商品库存实时同步
- 价格计算（优惠券、会员折扣、满减活动）
- 多地址配送费计算
- 支付接口对接
- 订单状态流转
- 库存锁定与释放机制

随着功能增加，组件间的交互呈指数级增长，一个小改动可能影响多个模块。

## 2. 一致性

**案例：第三方支付集成**

你的系统需要对接多个支付平台：

- 微信支付要求特定的签名算法和回调格式
- 支付宝有自己的一套 API 规范
- PayPal 使用完全不同的认证机制
- 银行网关又有另一套标准

你必须让代码适应每个外部系统的"任性"规则，即使它们互相矛盾或不合理。

## 3. 可变性

**案例：社交媒体 App 的"点赞"功能演变**

- **第 1 版**：简单的点赞/取消点赞
- **第 2 版**：需求改为支持 6 种表情反应（学 Facebook）
- **第 3 版**：要加上长按预览谁点了赞
- **第 4 版**：市场部要求添加点赞动画特效
- **第 5 版**：运营要统计不同年龄段用户的表情偏好
- **第 6 版**：法务要求添加"不当点赞"的撤回追溯功能

软件的可变性导致它不断被要求修改，而物理产品（如桥梁）建好后很少改变核心结构。

## 4. 不可见性

**案例：微服务架构的请求链路**

当用户在 App 上点击"下单"按钮时，背后可能发生：

```
前端 → API 网关 → 订单服务 → 库存服务 → 价格服务 
                           ↓
                      消息队列 → 物流服务 → 仓储服务
                           ↓
                      支付服务 → 风控服务 → 通知服务
```

这个调用链路是**不可见的**：

- 无法像建筑图纸一样直观展示
- 数据流向难以追踪
- 出现 bug 时很难定位问题在哪个环节
- 新人需要很长时间才能理解整个系统的运作方式

即使用流程图表示，也很难完整呈现所有异步流程、异常处理、重试机制等复杂逻辑。